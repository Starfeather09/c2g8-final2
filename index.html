<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>八二班 消消乐</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f8ff;
            font-family: "Microsoft YaHei", sans-serif;
            padding: 20px;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        /* 游戏棋盘样式 */
        .game-board {
            display: grid;
            grid-template-columns: repeat(7, 80px);
            grid-template-rows: repeat(7, 80px);
            gap: 5px;
            background-color: #ddd;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* 格子样式 */
        .cell {
            width: 80px;
            height: 80px;
            background-color: #fff;
            border-radius: 4px;
            overflow: hidden;
            cursor: grab;
            transition: transform 0.2s ease;
        }

        .cell img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 保持图片比例并填充格子 */
        }

        .cell:active {
            cursor: grabbing;
        }

        /* 选中格子高亮 */
        .cell.selected {
            border: 3px solid #ff6b6b;
        }

        /* 消除动画 */
        @keyframes disappear {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(0); }
        }

        .disappear {
            animation: disappear 0.5s forwards;
        }

        /* 旋转动画 - 新增 */
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
            100% { transform: rotate(360deg); }
        }

        .cell.rotating {
            animation: rotate 3s linear infinite;
        }

        /* 分数显示 */
        .score {
            font-size: 24px;
            font-weight: bold;
            margin-top: 20px;
            color: #333;
        }

        /* 提示文本 */
        .tip {
            color: #666;
            margin-bottom: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <button onclick="document.getElementById('bgm').play()">神秘小按钮</button>
    <audio id="bgm" src="wyb.mp3" loop style="display:none"></audio>
    <h1>八二班神人消消乐</h1>
    <div class="tip">张吉人视角</div>
    <div class="score">分数: <span id="score">0</span></div>
    <div class="game-board" id="gameBoard"></div>

    <script>
        // 配置项
        const BOARD_SIZE = 7; // 7x7 棋盘
        // 本地图片路径（HTML同级目录，图片命名为img1.png ~ img6.png）
        const ITEM_IMAGES = [
            "img1.png",
            "img2.gif",
            "img3.png",
            "img4.png",
            "img5.png",
            "img6.png"
        ];
        
        // 需要旋转的图片索引（img2.gif的索引是1）
        const ROTATING_ITEM_INDEX = 1;
        
        let gameBoard = []; // 存储棋盘数据（每个格子的图片索引）
        let selectedCell = null; // 选中的格子
        let score = 0; // 分数
        const scoreElement = document.getElementById('score');
        const boardElement = document.getElementById('gameBoard');

        // 初始化棋盘
        function initBoard() {
            gameBoard = [];
            boardElement.innerHTML = '';
            
            // 随机生成7x7棋盘数据
            for (let row = 0; row < BOARD_SIZE; row++) {
                gameBoard[row] = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // 随机选择图片索引
                    const randomImgIndex = Math.floor(Math.random() * ITEM_IMAGES.length);
                    gameBoard[row][col] = randomImgIndex;
                    
                    // 创建格子元素
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // 创建图片元素
                    const img = document.createElement('img');
                    img.src = ITEM_IMAGES[randomImgIndex];
                    img.alt = `item-${randomImgIndex}`;
                    
                    // 图片加载失败时显示占位符
                    img.onerror = function() {
                        this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI0MCIgY3k9IjQwIiByPSI0MCIgZmlsbD0iIzE4MTgxOCIvPjxwYXRoIGQ9Ik00MCAyNUMyNy45IDI1IDE4IDM0LjkgMTggNDdTMjcuOSA2OSA0MCA2OUw0MCA0N0w0MCAyNVoiIGZpbGw9IiM0QTQ5NDkiLz48L3N2Zz4=';
                        this.alt = '图片加载失败';
                    };
                    cell.appendChild(img);
                    
                    // 如果是需要旋转的图片，添加旋转类
                    if (randomImgIndex === ROTATING_ITEM_INDEX) {
                        cell.classList.add('rotating');
                    }
                    
                    // 绑定点击事件（选中/交换）
                    cell.addEventListener('click', handleCellClick);
                    
                    boardElement.appendChild(cell);
                }
            }

            // 检查初始棋盘是否有可消除的元素，若有则重新生成（避免开局直接消除）
            const matchedCells = checkMatches();
            if (matchedCells.length > 0) {
                initBoard();
            }
        }

        // 处理格子点击事件
        function handleCellClick(e) {
            const cell = e.currentTarget;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // 第一次点击：选中格子
            if (!selectedCell) {
                selectedCell = { row, col, element: cell };
                cell.classList.add('selected');
                return;
            }

            // 第二次点击：判断是否为相邻格子
            const isAdjacent = 
                (Math.abs(row - selectedCell.row) === 1 && col === selectedCell.col) || // 上下相邻
                (Math.abs(col - selectedCell.col) === 1 && row === selectedCell.row); // 左右相邻

            if (isAdjacent) {
                // 交换格子内容
                swapCells(selectedCell.row, selectedCell.col, row, col);
                
                // 检查交换后是否有匹配的元素
                const matchedCells = checkMatches();
                if (matchedCells.length > 0) {
                    // 有匹配则消除并加分
                    removeMatchedCells(matchedCells);
                } else {
                    // 无匹配则恢复交换
                    swapCells(selectedCell.row, selectedCell.col, row, col);
                }
            }

            // 取消选中状态
            selectedCell.element.classList.remove('selected');
            selectedCell = null;
        }

        // 交换两个格子的内容
        function swapCells(row1, col1, row2, col2) {
            // 交换数据
            [gameBoard[row1][col1], gameBoard[row2][col2]] = [gameBoard[row2][col2], gameBoard[row1][col1]];
            
            // 交换DOM元素中的图片
            const cell1 = getCellElement(row1, col1);
            const cell2 = getCellElement(row2, col2);
            const img1 = cell1.querySelector('img');
            const img2 = cell2.querySelector('img');
            
            [img1.src, img2.src] = [img2.src, img1.src];
            [img1.alt, img2.alt] = [img2.alt, img1.alt];
            
            // 更新旋转类
            updateRotatingClass(cell1, gameBoard[row1][col1]);
            updateRotatingClass(cell2, gameBoard[row2][col2]);
        }

        // 获取指定位置的格子元素
        function getCellElement(row, col) {
            return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
        }

        // 更新旋转类
        function updateRotatingClass(cell, imgIndex) {
            if (imgIndex === ROTATING_ITEM_INDEX) {
                cell.classList.add('rotating');
            } else {
                cell.classList.remove('rotating');
            }
        }

        // 检查所有匹配的元素（横向/纵向3个及以上）
        function checkMatches() {
            const matchedCells = new Set(); // 存储匹配的格子（避免重复）

            // 检查横向匹配
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE - 2; col++) {
                    const current = gameBoard[row][col];
                    // 连续3个相同
                    if (current === gameBoard[row][col+1] && current === gameBoard[row][col+2]) {
                        // 标记匹配的格子
                        for (let i = 0; i < 3; i++) {
                            matchedCells.add(`${row}-${col+i}`);
                        }
                        // 处理超过3个的连续匹配（如4个、5个）
                        let nextCol = col + 3;
                        while (nextCol < BOARD_SIZE && gameBoard[row][nextCol] === current) {
                            matchedCells.add(`${row}-${nextCol}`);
                            nextCol++;
                        }
                    }
                }
            }

            // 检查纵向匹配
            for (let col = 0; col < BOARD_SIZE; col++) {
                for (let row = 0; row < BOARD_SIZE - 2; row++) {
                    const current = gameBoard[row][col];
                    // 连续3个相同
                    if (current === gameBoard[row+1][col] && current === gameBoard[row+2][col]) {
                        // 标记匹配的格子
                        for (let i = 0; i < 3; i++) {
                            matchedCells.add(`${row+i}-${col}`);
                        }
                        // 处理超过3个的连续匹配
                        let nextRow = row + 3;
                        while (nextRow < BOARD_SIZE && gameBoard[nextRow][col] === current) {
                            matchedCells.add(`${nextRow}-${col}`);
                            nextRow++;
                        }
                    }
                }
            }

            // 转换为数组格式 [{row, col}, ...]
            return Array.from(matchedCells).map(str => {
                const [r, c] = str.split('-').map(Number);
                return { row: r, col: c };
            });
        }

        // 移除匹配的格子并填充新元素
        function removeMatchedCells(matchedCells) {
            // 加分（每个匹配格子加10分）
            score += matchedCells.length * 10;
            scoreElement.textContent = score;

            // 添加消除动画
            matchedCells.forEach(({ row, col }) => {
                const cell = getCellElement(row, col);
                cell.classList.add('disappear');
            });

            // 动画结束后更新棋盘
            setTimeout(() => {
                // 1. 移除消除的格子内容
                matchedCells.forEach(({ row, col }) => {
                    gameBoard[row][col] = -1; // 标记为空
                    const cell = getCellElement(row, col);
                    cell.classList.remove('disappear');
                });

                // 2. 处理列的下落（类似重力效果）
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const emptyRows = []; // 记录当前列的空行位置
                    // 从下往上遍历，收集空行并填充
                    for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                        if (gameBoard[row][col] === -1) {
                            emptyRows.push(row);
                        } else if (emptyRows.length > 0) {
                            // 将非空元素下落
                            const targetRow = emptyRows.shift();
                            swapCells(row, col, targetRow, col);
                            emptyRows.push(row);
                            gameBoard[row][col] = -1;
                        }
                    }

                    // 3. 填充新元素到顶部空行
                    emptyRows.forEach(row => {
                        const randomImgIndex = Math.floor(Math.random() * ITEM_IMAGES.length);
                        gameBoard[row][col] = randomImgIndex;
                        const cell = getCellElement(row, col);
                        const img = cell.querySelector('img');
                        img.src = ITEM_IMAGES[randomImgIndex];
                        img.alt = `item-${randomImgIndex}`;
                        // 图片加载失败处理
                        img.onerror = function() {
                            this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI0MCIgY3k9IjQwIiByPSI0MCIgZmlsbD0iIzE4MTgxOCIvPjxwYXRoIGQ9Ik00MCAyNUMyNy45IDI1IDE4IDM0LjkgMTggNDdTMjcuOSA2OSA0MCA2OUw0MCA0N0w0MCAyNVoiIGZpbGw9IiM0QTQ5NDkiLz48L3N2Zz4=';
                            this.alt = '图片加载失败';
                        };
                        
                        // 更新旋转类
                        updateRotatingClass(cell, randomImgIndex);
                    });
                }

                // 4. 检查新棋盘是否有连锁消除
                const newMatchedCells = checkMatches();
                if (newMatchedCells.length > 0) {
                    setTimeout(() => removeMatchedCells(newMatchedCells), 300);
                }
            }, 500);
        }

        // 初始化游戏
        initBoard();
    </script>
</body>
</html>